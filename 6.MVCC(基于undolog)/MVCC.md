**完整参考**：[正确的理解MySQL的MVCC及实现原理](https://blog.csdn.net/SnailMann/article/details/94724197)
# **MVCC**：
## 概念
多版本并发控制，解决读写冲突，通过**3个隐式字段**（事务 ID，回滚指针，隐藏主键）**、undo日志** ， **Read View**来实现。

-------------------

某事务x在对某条记录进行快照读（不加锁）时会创建`Read View`，`Read View`确保事务x只会读取到**这条记录在创建`Read View`之前已经被其它事务`修改并提交`的版本**。
**下面两种情况的记录版本均不会被快照读可见，这时会通过回滚指针来找到之前符合条件的版本读取：**

1.当前事务x快照读的版本是被其它正在活跃的事务修改了但并未提交的版本（活跃的事务就是指还未完成提交的事务）
2.当前事务x快照读的版本是其触发快照读创建`Read View`之后才被其它事务修改并提交的版本（这个事务是在快照读触发之后才创建的）

--------------
## 当前读和快照读在 RR 级别下的区别：
**RC（读已提交）** 隔离级别下，事务x的中每次快照读读操作都会生成并获取最新的 Read View；`因此如过事务A读取之后事务B修改了数据，事务A再次读取就会读取到最新的数据，导致不可重复读问题`
**RR （可重复读）**，隔离级别下，事务x的中只有第一次快照读才会创建 Read View, 之后`事务x的快照读获取的都是同一个 Read View`即第一次创建的Read View。

**表1**:
| 事务A                       | 事务B                                    |
| --------------------------- | ---------------------------------------- |
| 开启事务                    | 开启事务                                 |
| 快照读(无影响)查询金额为500 | 快照读查询金额为500                      |
| 更新金额为400               |                                          |
| 提交事务                    |                                          |
|                             | select 快照读金额为500                   |
|                             | select lock in share mode当前读金额为400 |
在上表的顺序下，事务 B 的在事务 A 提交修改后的快照读是旧版本数据，而当前读是实时新数据 400
**表2：**
| 事务A                         | 事务B                                    |
| ----------------------------- | ---------------------------------------- |
| 开启事务                      | 开启事务                                 |
| 快照读（无影响）查询金额为500 |                                          |
| 更新金额为400                 |                                          |
| 提交事务                      |                                          |
|                               | select 快照读金额为400                   |
|                               | select lock in share mode当前读金额为400 |
这里与上表的唯一区别仅仅是表 1的事务 B 在事务 A 修改金额前快照读过一次金额数据，而表 2的事务B在事务A修改金额前没有进行过快照读。

⭐**因此在可重复读的隔离下解决了不可重复读的问题仅针对快照读，当前读仍然会发生**
------
**锁方面的总结：**
简单来说快照读就是MVCC思想在MySQL的具体非阻塞读功能实现，整个MVCC多并发控制的目的就是为了实现读-写冲突不加锁，提高并发读写性能，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现

