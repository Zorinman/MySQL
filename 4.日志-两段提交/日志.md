[参考1](https://javaguide.cn/database/mysql/mysql-logs.html#%E6%80%BB%E7%BB%93)
[参考2](https://cloud.tencent.com/developer/article/2493872)

## MySQL日志主要包括八种
**⭐二进制日志**(bin log)：记录所有更改数据的语句，用于主从服务器之间的数据同步、服务器遇到故障时数据的无损恢复
**⭐回滚日志**（undo log）：是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC
**⭐重做日志**（redo log）：是Innodb存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复
**中继日志**（relay log）：用于主从服务器架构，从服务器用来存放主服务器二进制日志内容的一个中间件文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作
**慢查询日志**(slow query log)：记录所有执行时间超过long_query_time的所有查询，方便对查询进行优化
**通用查询日志**（general log）：记录索引连接的起始时间和终止时间，以及连接发送给数据库服务的所有指令，对复原操作的实际场景、发现问题、数据库操作的审计都有帮助
**错误日志**（error log）：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便了解服务器的状态，从而对服务器进行维护
**数据定义语句日志**：记录数据定义语句执行的元数据操作
除了二进制日志外，其他日志均为文本文件。默认情况下，所有日志均创建于MySQL数据目录中
![alt text](图片\image.png)

------------------
**下面主要介绍三种重要日志`二进制日志`，`回滚日志`，`重做日志`**
## 概要（redolog、bin log 、undolog）
**事务日志redolog（重做日志）**：
是Innodb存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复
- 在事务执行期间mysql也会将记录持续写入到redo log buffer 当中，`并通过后台线程进行写入和刷盘`；
- 事务提交时根据配置的策略进行强制写入和刷盘
  
**二进制bin log（归档日志）**：
是Server层生成的日志，主要用于数据备份和主从复制
- 事务执行过程中，仅先把日志写入bin log cache`不写入和刷盘`；
- 事务提交时，根据配置策略进行写入和刷盘

**undolog（回滚日志）**：是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC；


## 1.redo log（重做日志）
### 为什么需要 redo log？

在 MySQL 中，如果每一次的更新要写进磁盘，这么做会带来严重的性能问题：

因为 Innodb 是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这时将完整的数据页刷到磁盘的话，太浪费资源了！而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。如果是写 redo log，一行记录可能就占几十 Byte，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。

一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机 IO 写入性能太差！

--------
### 基本介绍

MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。
![alt text](图片\image-1.png)


MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。

```
概念：
缓冲池（buffer pool）：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度
数据页（page）：是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据
MySQL中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，减少硬盘IO开销，提升性能。
更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。然后会把在某个数据页上做了什么修改记录到重做日志缓存(redo log buffer)里，接着刷盘到redo log文件里。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。
```
![alt text](图片\image-2.png)
### 刷盘时机
InnoDB 将 redo log 刷到磁盘上有几种情况：
- **⭐事务提交**：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过innodb_flush_log_at_trx_commit参数控制，后文会提到）。
- **log buffer 空间不足时**：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。
- **事务日志缓冲区满**：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。
- **Checkpoint（检查点）**：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。
- **后台刷新线程**：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。
- **正常关闭服务器**：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。我们要注意设置正确的刷盘策略innodb_flush_log_at_trx_commit 。根据 MySQL 配置的刷盘策略的不同，MySQL 宕机之后可能会存在轻微的数据丢失问题。

### 写入和刷盘机制
**在事务执行期间mysql也会将记录持续写入到redo log buffer 当中，并通过后台线程进行写入和刷盘**
InnoDB默认有一个后台线程进行轮询操作，每隔1 秒，就会把 `redo log buffer` 中的内容写到`文件系统缓存（page cache）`，然后调用 fsync 刷入系统硬盘。
![alt text](图片\image-3.png)
![alt text](图片\image-4.png)
**我们往往通过设置innodb_flush_log_at_trx_commit值来配置刷盘时机**，值有 3 种，也就是共有 3 种刷盘策略：


| 参数值                    | 事务执行期间（未提交时）                                                 | 事务提交时                                                                                                                                                                                                                                                                            |
| ------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **0（延迟写，延迟刷新）** | 写入 redo log buffer，但不会立即写入 page cache 或磁盘（每秒刷盘一次）。 | **不立刻强制写入和刷盘**，依赖后台线程每秒写入page cache和刷入磁盘（不会立刻将 redo log buffer 中日志写到 page cache，而是通过后台线程每秒写入 page cache 并调用 fsync() 写入到 redo logfile 中。也就是说设置为 0 时是大约每秒刷新写入到磁盘中的，当系统崩溃，会丢失 1 秒钟的数据）。 |
| **1（实时写、实时刷新）** | 写入 redo log buffer，但不会立即写入 page cache 或磁盘（每秒刷盘一次）。 | **立刻强制写入和刷盘**， 写入page cache 并调用 fsync() 刷入磁盘（会立刻将 redo log buffer 中的日志写入 page cache 并调用 fsync() 刷到 redo logfile 中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能差。）。                                          |
| **2（实时写、延迟刷新）** | 写入 redo log buffer，但不会立即写入 page cache 或磁盘（每秒刷盘一次）。 | **仅立刻强制写入但不刷盘**，立刻写入 page cache，不立即调用 fsync()（仅写入到 page cache，然后是通过后台线程每秒调用 fsync() 将 page cache 中的日志写入到 redo log file）。                                                                                                           |

⭐注意：因为存在后台线程，所以一个没有提交事务的 redo log 记录，也可能会刷盘

### 故障后数据丢失情况

`redo log buffer` 属于Mysql
`page cache` 属于操作系统
`redo.file` 属于硬盘
| 参数值 | 故障情况                                                                                                                                                                                                                                              |
| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0      | 事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失<br>**事务提交成功如果 MySQL 挂了或宕机，因为仅立即存储在 MySQL 中的 redo log buffer 而没有立即存储在 page cache 或者硬盘，所以可能会有 1 秒数据的丢失。** |
| 1      | 事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。<br> **事务提交成功 MySQL 挂了或宕机，redo log 记录就一定在硬盘里，不会有任何数据丢失。**                                                                |
| 2      | 事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失<br> **事务提交成功 MySQL 挂了，不会有任何数据丢失。<br> 如果是宕机，由于只立即写入到系统 page cache 没有写入到硬盘，因此可能会有 1 秒数据的丢失。**       |



### redo log file 的结构
硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。
比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。



它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。
![alt text](图片\image-5.png)
在这个日志文件组中还有两个重要的属性，分别是 `write pos`、`checkpoint`：

`write pos` 是当前记录的位置，一边写一边后移，**每次刷盘 redo log 记录到日志文件组中**，write pos 位置就会后移更新。
`checkpoint `是当前要擦除的位置，也是往后推移，**每次 MySQL 加载日志文件组恢复数据时**，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。

--------------
**write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。**
如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。
![alt text](图片\image-6.png)

## 2.bin log（二进制日志）
redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。而 bin log 是逻辑日志，记录内容是语句的原始逻辑，二进制日志（bin log）记录了所有的DDL（数据定义语言，创建库、表）语句和DML（数据操纵语言，增删改）语句，但不包括数据查询（SELECT、SHOW）语句。，属于MySQL Server 层

**作用：**
- 灾难时的数据恢复（通过使用 mysqlbin log 工具来恢复数据）；
- MySQL的主从复制（在Master端开启bin log ，每个从库读取bin log、写到暂存日志relay log中，slave端重放bin log 从而达到主从数据一致）。
![alt text](图片\image-7.png)

### 日志格式
**bin log 日志有三种格式，可以通过bin log_format参数指定。**
- statement
- row
- mixed

#### statement
指定statement，记录的内容是SQL语句原文，比如执行一条update T set update_time=now() where id=1，记录的内容如下。

![alt text](图片\image-8.png)
同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。为了解决这种问题，我们需要指定为row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据。
#### row 
![alt text](图片\image-9.png)
row格式记录的内容看不到详细信息，要通过mysqlbin log工具解析出来。update_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（假设这张表只有 3 个字段）。这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗 IO 资源，影响执行速度。所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。

#### mixed
mixed下MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式



### 写入和刷盘机制
**事务执行过程中，先把日志写入bin log cache，事务提交时，再把bin log cache写到bin log文件中。**
一个事务的bin log不能被拆开，确保一次性写入，系统将给每个线程分配一块内存作为bin log cache
![alt text](图片\image-10.png)
上图的 `write`是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快
上图的 `fsync`，才是将数据持久化到磁盘的操作

----------

对于InnoDB存储引擎而言，只有在事务提交时才会记录bin log，那么bin log什么时候才会将内存中的数据刷到磁盘呢？其实mysql是通过sync_bin log参数控制bin log的刷盘时机，取值范围是0-N【write和fsync的时机，由参数sync_bin log控制，默认为0】

| 参数值 | 含义                                                                                                                                                                   |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0      | 每次提交事务都只 write，由系统自行判断什么时候执行 fsync。虽然性能得到提升，但是机器宕机时，page cache 里的 bin log 会丢失（不强制要求，由系统自行判断何时写入磁盘）。 |
| 1      | 每次提交事务都会执行 fsync，如同 redo log 刷盘流程一样（每次 commit 的时候都要将 bin log 写入磁盘）。                                                                  |
| N      | 每次提交事务都 write，但累计 N 个事务后才 fsync（每 N 个事务，才会将 bin log 写入磁盘）。                                                                              |


## 两阶段提交（解决redo log 和bin log 数据不一致）
redo log（重做日志）让 InnoDB 存储引擎拥有了崩溃恢复能力。

bin log（归档日志）保证了 MySQL 集群架构的数据一致性。
虽然它们都属于持久化的保证，但是侧重点不同。
在执行更新语句过程中，会记录 redo log 与 bin log 两块日志，以基本的事务为单位：
- **redo log 在事务执行过程中可以不断写入**
- **bin log 只有在提交事务时才写入，所以 redo log 与 bin log 的写入时机不一样。**
![alt text](图片\image-11.png)

### 数据不一致问题
redo log 与 bin log 两份日志之间的逻辑不一致，会出现什么问题？我们以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c=1 where id=2。
**假设执行过程中写完 redo log 日志后，bin log 日志写期间发生了异常，会出现什么情况呢？**
![alt text](图片\image-12.png)
由于 bin log 没写完就异常，这时候 bin log 里面没有对应的修改记录。因此，之后用 bin log 日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为 redo log 日志恢复，这一行c值是1，最终数据不一致。
![alt text](图片\image-13.png)


### 两阶段提交方案( redo log 的写入拆成了两个步骤prepare和commit)
为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。
**将 redo log 的写入拆成了两个步骤prepare和commit，这就是两阶段提交。**
![alt text](图片\image-14.png)

使用两阶段提交后，写入 bin log 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于prepare阶段，并且没有对应 bin log 日志，就会回滚该事务。
![alt text](图片\image-15.png)
再看一个场景，redo log 设置commit阶段发生异常，那会不会回滚事务呢？
![alt text](图片\image-16.png)
并不会回滚事务，它会执行上图框住的逻辑，虽然 redo log 是处于prepare阶段，但是能通过事务id找到对应的 bin log 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。

## .3 回滚日志(undo log)
undo log（回滚日志）：是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
它是InnoDB存储引擎在insert、update、delete的时候产生的便于数据回滚的日志。在数据更新之前，MySQL就需要先把更新前的数据记录到 undo log 日志中，当事务回滚时，可以利用 undo log 来进行回滚。作用包含两个——提供回滚、MVCC（多版本并发控制）。
**undo log主要分为两种**：
- **insert undo log**：当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除（因为这种log只是对本事务可见，其他事务不可见，所以当事务提交后，这种类型的undo log就会被系统直接删除回收，也就是该undo log占用的undo页面链表被释放）。
- **update/delete undo log**：update、delete的时候，产生的undo log日志不仅在事务回滚时需要，在快照读时也需要（也就是MVCC），所以不能在事务提交后马上删除，只在提交后放入undo log的链表，等待purge线程进行最后的删除。

### 提供回滚：
比如现在Tom的账户余额有100，现在有一个事务需要把Tom的账户余额更新为300，大致的流程如下图
![alt text](图片\image-17.png)

### MVCC
[点击此处查看](..\MVCC\MVCC.md)