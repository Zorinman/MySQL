**在 MySQL InnoDB 引擎中，读操作主要分为当前读和快照读**

**在 MySQL InnoDB 引擎中默认都使用快照读-`只要 SELECT 没有加 FOR UPDATE 或 LOCK IN SHARE MODE，就是快照读`**

# 1. 快照读（Snapshot Read）
## 特点：
- 不加锁

- 使用 MVCC（多版本并发控制） 实现一致性读

- 读取的是事务第一次执行快照读时（RR隔离下）或事务每次快照读语句开始时（RC隔离下）生成的 一致性视图中的数据

- 不会阻塞，也不会被阻塞


## 常见语句：
```sql
SELECT * FROM users WHERE id = 1;
```


# 2. 当前读（Current Read）
## 特点：
- 加锁

- 读取的是最新的、已经提交的记录，同时加锁保证数据不会被其他事务修改
- 
- 用于获取数据并打算后续更新它（UPDATA、DELETE、INSERT）

- 会阻塞或被阻塞

## 常见语句：

```sql
SELECT * FROM users WHERE id = 1 FOR UPDATE;

SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

UPDATE users SET name = 'Tom' WHERE id = 1;

DELETE FROM users WHERE id = 1;

INSERT INTO ...;
```

所有 更新类语句（DML） 本质上也属于“当前读”，因为它们会读取数据后执行更新并加锁。





# 当前读和快照读在 RR 级别下的区别
**RC（读已提交）** 隔离级别下，事务x的中每次快照读读操作都会生成并获取最新的 Read View；`因此如过事务A读取之后事务B修改了数据，事务A再次读取就会读取到最新的数据，导致不可重复读问题`
**RR （可重复读）**，隔离级别下，事务x的中只有第一次快照读才会创建 Read View, 之后`事务x的快照读获取的都是同一个 Read View`即第一次创建的Read View。

**表1**:
| 事务A                       | 事务B                                    |
| --------------------------- | ---------------------------------------- |
| 开启事务                    | 开启事务                                 |
| 快照读(无影响)查询金额为500 | 快照读查询金额为500                      |
| 更新金额为400               |                                          |
| 提交事务                    |                                          |
|                             | select 快照读金额为500                   |
|                             | select lock in share mode当前读金额为400 |
在上表的顺序下，事务 B 的在事务 A 提交修改后的快照读是旧版本数据，而当前读是实时新数据 400
**表2：**
| 事务A                         | 事务B                                    |
| ----------------------------- | ---------------------------------------- |
| 开启事务                      | 开启事务                                 |
| 快照读（无影响）查询金额为500 |                                          |
| 更新金额为400                 |                                          |
| 提交事务                      |                                          |
|                               | select 快照读金额为400                   |
|                               | select lock in share mode当前读金额为400 |
这里与上表的唯一区别仅仅是表 1的事务 B 在事务 A 修改金额前快照读过一次金额数据，而表 2的事务B在事务A修改金额前没有进行过快照读。

⭐**因此在可重复读的隔离下解决了不可重复读的问题仅针对快照读，当前读仍然会发生**