https://blog.csdn.net/SnailMann/article/details/88299127
https://javaguide.cn/database/mysql/transaction-isolation-level.html

## 事务操作可能会出现的数据问题
**脏读**
事务A修改了数据，但未提交，而事务B查询了事务A修改过却没有提交的数据，这就是脏读，因为事务A可能会回滚
**不可重复读**
事务A 先 查询了金额，是200块钱，未提交 。事务B在事务A查询完之后，修改了金额，变成了300, 在事务A前提交了；如果此时事务A再查询一次数据，就会发现钱跟上一次查询不一致，是300，而不是200。这就是不可重复读。强调事务A对要操作的数据被别人修改了，但在不知请的情况下拿去做之前的用途
**幻读**
事务A先修改了某个表的所有纪录的状态字段为已处理，未提交；事务B也在此时新增了一条未处理的记录，并提交了；事务A随后查询记录，却发现有一条记录是未处理的，很是诧异，刚刚不是全部修改为已处理嘛，以为出现了幻觉或者假设事务 1 读取一组满足某些搜索条件的行。事务 2 生成与事务 1 的搜索条件匹配的新行（通过更新或插入）。如果事务 1 重新执行读取行的语句，它将获得一组不同的行。这就是幻读

**数据库中总共就4个操作: 增，删，改，查**
`脏读`说的是事务A查询到了其它事务还未提交的数据，强调的动作是查询，我看到了自己不该看的东西 ; 
`不可重复读`强调的是一个事务A查的时候，其他事务却可以增删改, 导致`在事务A期间`两次查询同一数据的值不一致，但事务A却不知道数据什么时候被改了。（**事务第二次查询数据本身值被修改**）
`幻读`强调的是`事务A期间`中修改了数据，但`事务A期间`再次查询的时候，却发现新增了一条没有修改的数据，为什么，因为其他事务人插了一条新的（**事务第二次查询同一查询语句新增了一条数据**）


## 事务隔离级别([建议查看实际情况演示](https://javaguide.cn/database/mysql/transaction-isolation-level.html))
SQL 标准定义了四个隔离级别：

**READ-UNCOMMITTED(读取未提交)** ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

**READ-COMMITTED(读取已提交)** ：允许在某事务中读取到并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

**REPEATABLE-READ(可重复读)** ：`在一个事务内`对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读（`仅针对快照读而不是当前读`具体看MVCC），但幻读仍有可能发生。⭐使用当前读仍会发生不可重复读问题

**SERIALIZABLE(可串行化)** ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过`SELECT @@tx_isolation`;命令来查看，MySQL 8.0 该命令改为SELECT `@@transaction_isolation;`

REPEATABLE-READ(可重复读)是不可以防止幻读的。
但是！**InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：**
- 快照读：由 MVCC 机制来保证不出现幻读。
- 当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。
 
因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。


[实例演示](https://javaguide.cn/database/mysql/transaction-isolation-level.html#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%80%BB%E7%BB%93)

